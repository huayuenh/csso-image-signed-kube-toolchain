---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: csso-signing-task
spec:
  params:
    - name: continuous-delivery-context-secret
      description: name of the configmap containing the continuous delivery pipeline context secrets
      default: secure-properties
    - name: kubernetes-service-apikey-secret-key
      description: field in the secret that contains the api key used to login to ibmcloud kubernetes service
      default: apikey
    - name: vault-instance
    - name: key-name
    - name: region
    - name: resource-group
    - name: registry-region
    - name: registry-namespace
    - name: image-name
  steps:
    - name: sign-image
      image: huayuenh/csso_client:latest
      env:
        - name: VAULT_INSTANCE
          value: $(params.vault-instance)
        - name: KEY_NAME
          value: $(params.key-name)
        - name: IBMCLOUD_TARGET_REGION
          value: $(params.region)
        - name: RESOURCE_GROUP
          value: $(params.resource-group)
        - name: REGISTRY_REGION
          value: $(params.registry-region)
        - name: REGISTRY_NAMESPACE
          value: $(params.registry-namespace)
        - name: IMAGE_NAME
          value: $(params.image-name)
        - name: REGION
          value: $(params.region)
        - name: IBM_CLOUD_API_KEY
          valueFrom:
            secretKeyRef:
              name: $(params.continuous-delivery-context-secret)
              key: $(params.kubernetes-service-apikey-secret-key)
      script: |
          #!/bin/bash
          source /artifacts/build.properties
          IMAGE_TAG=$IMAGE_TAGS
          #Required parameters
          #VAULT_INSTANCE - name of the Key-Protect instance
          #KEY_NAME - name of the key entry in Key-Protect key name must match CSSO cert name
          #REGION - region containing the Key-Protect instance
          #RESOURCE_GROUP - "Default" by default. Resource Group of Key-Protect
          #IBM_CLOUD_API_KEY - access ibm cloud apikey
          #IMAGE_NAME - name of the image
          #IMAGE_TAG - the required tag name
          #REGISTRY_NAMESPACE - the namespace of the registry containing storing the images

          ibmcloud login --apikey "$IBM_CLOUD_API_KEY" -r "$IBMCLOUD_TARGET_REGION";

          ibmcloud target -r ${REGISTRY_REGION}
          #REGISTRY_URL - the registry URL e.g. us.icr.io, de.icr.io
          REGISTRY_URL=$(ibmcloud cr info | grep -w 'Container Registry' | awk '{print $3;}' | grep -w 'icr')
          ibmcloud target -r ${IBMCLOUD_TARGET_REGION}



          echo "VAULT_INSTANCE $VAULT_INSTANCE"
          echo "KEY_NAME $KEY_NAME"
          echo "REGION $REGION"
          echo "RESOURCE_GROUP $RESOURCE_GROUP"
          echo "IBM_CLOUD_API_KEY $IBM_CLOUD_API_KEY"
          echo "IMAGE_NAME $IMAGE_NAME"
          echo "IMAGE_TAG $IMAGE_TAG"
          echo "REGISTRY_NAMESPACE $REGISTRY_NAMESPACE"
          echo "REGISTRY_URL $REGISTRY_URL"

          #Use utility script for reading from Key Protect
          function retrieve_secret {

              VAULT_SERVICE_NAME=$1 #name of the Key-Protect instance
              VAULT_REGION=$2 #region where the Key-Instance was set up -> us-south
              RESOURCE_GROUP=$3 # Default
              SECRET_NAME=$4 
              APIKEY=$5 #access apikey

              #exit if any of these values are not set
              check_value ${VAULT_SERVICE_NAME}
              check_value ${VAULT_REGION}
              check_value ${RESOURCE_GROUP}
              check_value ${SECRET_NAME}
              check_value ${APIKEY}

              #Get the Key-Protect instance UUID    
              VAULT_INSTANCE_GUID=$(get_guid $VAULT_SERVICE_NAME)

              #Generate the IAM Bearer token
              VAULT_ACCESS_TOKEN=$(get_access_token $APIKEY)
              check_value $VAULT_ACCESS_TOKEN

              #Get list of all keys in specified instance
              LIST_OF_KEYS=$(get_keys "$VAULT_REGION" "$VAULT_ACCESS_TOKEN" "$VAULT_INSTANCE_GUID")
              check_value ${LIST_OF_KEYS}

              #Get Key UUID of named key
              KEY_UUID=$(echo "$LIST_OF_KEYS" | jq -e -r '.resources[] | select(.name=="'${SECRET_NAME}'") | .id')
              check_value ${KEY_UUID}

              KEY_DATA=$(get_key_value "$VAULT_REGION" "$VAULT_ACCESS_TOKEN" "$VAULT_INSTANCE_GUID" "$KEY_UUID")
              check_value ${KEY_DATA}
              KEY_VALUE=$(echo "$KEY_DATA" | jq -e -r '.resources[] | select(.name=="'${SECRET_NAME}'") | .payload')
              echo "$KEY_VALUE"
          }

          # returns an IAM access token given an API key
          function get_access_token {
            IAM_ACCESS_TOKEN_FULL=$(curl -s -k -X POST \
            --header "Content-Type: application/x-www-form-urlencoded" \
            --header "Accept: application/json" \
            --data-urlencode "grant_type=urn:ibm:params:oauth:grant-type:apikey" \
            --data-urlencode "apikey=$1" \
            "https://iam.cloud.ibm.com/identity/token")
            IAM_ACCESS_TOKEN=$(echo "$IAM_ACCESS_TOKEN_FULL" | \
              grep -Eo '"access_token":"[^"]+"' | \
              awk '{split($0,a,":"); print a[2]}' | \
              tr -d \")
            echo $IAM_ACCESS_TOKEN
          }

          #retrieves data for all keys in specified Key-Protect instance
          function get_keys {
            REGION=$1
            IAMTOKEN=$2
            INSTANCE_ID=$3
            list=$(curl https://us-south.kms.cloud.ibm.com/api/v2/keys \
            -H "authorization: Bearer ${IAMTOKEN}"\
            -H "bluemix-instance: ${INSTANCE_ID}"\
            -H "accept: application/vnd.ibm.kms.key+json")
            echo $list
          }

          #retrieves a specific key payload
          function get_key_value {
            REGION=$1
            IAMTOKEN=$2
            INSTANCE_ID=$3
            KEY_UUID=$4
            payload=$(curl https://us-south.kms.cloud.ibm.com/api/v2/keys/${KEY_UUID} \
            -H "authorization: Bearer ${IAMTOKEN}"\
            -H "bluemix-instance: ${INSTANCE_ID}"\
            -H "accept: application/vnd.ibm.kms.key+json")
            echo $payload
          }

          # returns a service GUID given a service name
          function get_guid {
            OUTPUT=$(ibmcloud resource service-instance --id $1)
            if (echo $OUTPUT | grep -q "crn:v1" >/dev/null); then
              echo $OUTPUT | awk -F ":" '{print $8}'
            else
              echo "Failed to get GUID: $OUTPUT"
              exit 2
            fi
          }

          function check_value {
            if [ -z "$1" ]; then
              exit 1
            fi

            if echo $1 | grep -q -i "failed"; then
              exit 2
            fi
          }
          export secret=$(retrieve_secret "${VAULT_INSTANCE}" "${IBMCLOUD_TARGET_REGION}" "${RESOURCE_GROUP}" "${KEY_NAME}" "${IBM_CLOUD_API_KEY}")
          export filename=${KEY_NAME}

          #create python script for decoding base64 binary file
          #handles binary data better than bash
          cat << EOF > decode.py
          #!/usr/bin/env python
          import base64
          import os
          inputdata=os.environ["secret"]
          outputname=os.environ["filename"]
          result=base64.b64decode(inputdata)
          f=open(outputname, 'wb')
          f.write(result)
          EOF

          chmod 755 ./decode.py

          echo "CHECK PYTHON3 version"
          python3 --version
          #run python script
          echo "RESTORING KEY DATA"
          python3 ./decode.py
          ls -a /etc/ekm
          mv ./$KEY_NAME /etc/ekm
          echo "****************"
          ls -a /etc/ekm

          #extract alias
          ALIAS=$(ucl list)
          ALIAS=${ALIAS%"Private"*}
          ALIAS=${ALIAS#*"Name="}
          ALIAS="${ALIAS//\"}"
          echo "Alias: $ALIAS"

          gpgconf --kill all
          ucl pgp-key -n ${ALIAS}
          FINGERPRINT=$(gpg2 -k)
          FINGERPRINT=${FINGERPRINT%"uid"*}
          FINGERPRINT=${FINGERPRINT#*"[SCEA]"}
          FINGERPRINT=$(echo ${FINGERPRINT} | sed 's/^[ \t]*//;s/[ \t]*$//')
          echo "FINGERPRINT $FINGERPRINT"
          gpg --list-keys
          ls -a /root/.gnupg

          SIGNING_DIR="signing"
          mkdir ${SIGNING_DIR}

          SIGNING_KEY=${FINGERPRINT}

          #Note - signing can be done performed using a single skopeo command
          #echo "PULL IMAGE"
          #skopeo copy docker://${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}:${IMAGE_TAG} dir:${SIGNING_DIR} --src-creds iamapikey:${IBM_CLOUD_API_KEY}
          #echo "BEGIN SIGNING PUSH TO REPO"
          #skopeo copy dir:${SIGNING_DIR} docker://${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}:${IMAGE_TAG} --dest-creds iamapikey:${IBM_CLOUD_API_KEY}  --sign-by ${SIGNING_KEY}
          echo "DIRECT REPO SIGNING"
          skopeo copy docker://${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}:${IMAGE_TAG} docker://${REGISTRY_URL}/${REGISTRY_NAMESPACE}/${IMAGE_NAME}:${IMAGE_TAG} --dest-creds iamapikey:${IBM_CLOUD_API_KEY} --src-creds iamapikey:${IBM_CLOUD_API_KEY} --sign-by ${SIGNING_KEY}
  workspaces:
    - name: artifacts
      description: A workspace backing by a volume
      mountPath: /artifacts